import {  createWalletClient,  createPublicClient,  http,  formatEther,  formatGwei,  parseEther,  parseAbi,  toHex,  encodeAbiParameters,  parseAbiParameters,  type Address,} from "viem";import { privateKeyToAccount } from "viem/accounts";import * as dotenv from "dotenv";import { getNetworkConfig, getCurrentNetwork, isMainnet } from "./config";dotenv.config();// ------------------------------// 鏂囦欢姒傝堪锛堜腑鏂囨敞閲婏級// ------------------------------// Facet 閾撅紙L2锛変笂鐨勫厬鎹?濂楀埄宸ュ叿锛?// - 閫氳繃 Uniswap V2 姹狅紙FCT/WETH锛夎幏鍙栨姤浠蜂笌鎵ц鍏戞崲// - 璁＄畻浠锋牸鍐插嚮锛坧rice impact锛変笌鎵ц浠锋牸锛坋ffective price锛?// - 鎻愪緵鈥滄寲鐭?vs 鍏戞崲鈥濈殑瀵规瘮涓庡缓璁紝鐢ㄤ簬鍐崇瓥/濂楀埄鍙傝€?// - 鍙綔涓虹嫭绔?CLI锛歲uote / swap// Get network configurationconst networkConfig = getNetworkConfig();const PRIVATE_KEY = process.env.PRIVATE_KEY;if (!PRIVATE_KEY) {  console.error("[ERROR] 缂哄皯 PRIVATE_KEY锛?env 鏈缃級 | PRIVATE_KEY not found in .env file");  process.exit(1);}const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);// FCT max supply in weiconst FCT_MAX_SUPPLY = 1646951661163841381479607357n;// DEX addresses on Facet (from config)// Base token on Facet L2 (WETH-L2), and FCT token (WFCT)const WETH_ADDRESS = networkConfig.wethAddress as `0x${string}`;const WRAPPED_FCT_ADDRESS = networkConfig.wfctAddress as `0x${string}`;const UNISWAP_V2_ROUTER = networkConfig.uniswapV2Router as `0x${string}`;// Uniswap V2 ABIsconst UNISWAP_V2_PAIR_ABI = parseAbi([  "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",  "function token0() external view returns (address)",  "function token1() external view returns (address)",]);const UNISWAP_V2_ROUTER_ABI = parseAbi([  "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)",  "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)",  "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)",]);// Uniswap V2 / FacetSwap Factory ABI (for dynamic pair resolution)const UNISWAP_V2_FACTORY_ABI = parseAbi([  "function getPair(address tokenA, address tokenB) external view returns (address pair)"]);// Get Facet chain configuration from network configconst facetChain = networkConfig.facetChain;const facetClient = createPublicClient({  chain: facetChain,  transport: http(networkConfig.facetRpcUrl),});const facetWalletClient = createWalletClient({  account,  chain: facetChain,  transport: http(networkConfig.facetRpcUrl),});// Resolve FacetSwap pair address dynamically via Factory.getPair(WFCT, WETH)async function resolveFacetPair(): Promise<`0x${string}`> {  const envFactory = process.env.FACETSWAP_FACTORY as `0x${string}` | undefined;  const cfgPair = (networkConfig as any).fctPair || networkConfig.fctWethPair;  if (envFactory) {    try {      const pair = await facetClient.readContract({        address: envFactory,        abi: UNISWAP_V2_FACTORY_ABI,        functionName: "getPair",        args: [WRAPPED_FCT_ADDRESS, WETH_ADDRESS],      });      const p = (pair as string).toLowerCase();      if (p !== "0x0000000000000000000000000000000000000000") {        return pair as `0x${string}`;      }    } catch (e) {      console.warn("[WARN] resolveFacetPair via factory failed, fallback to config pair:", e);    }  }  if (cfgPair) return cfgPair as `0x${string}`;  throw new Error("No pair address available. Provide FACETSWAP_FACTORY or set fctPair in config.");}// Calculate price impact for Uniswap V2// 璁＄畻 Uniswap V2 鐨勮緭鍑轰笌浠锋牸鍐插嚮锛堟亽瀹氫箻绉仛甯?+ 0.3% 鎵嬬画璐癸級function calculatePriceImpact(  amountIn: bigint,  reserveIn: bigint,  reserveOut: bigint): { amountOut: bigint; priceImpact: number } {  // Uniswap V2 formula with 0.3% fee  const amountInWithFee = amountIn * 997n;  const numerator = amountInWithFee * reserveOut;  const denominator = reserveIn * 1000n + amountInWithFee;  const amountOut = numerator / denominator;  // Calculate price impact  const spotPrice = (reserveIn * 10n ** 18n) / reserveOut;  const newReserveIn = reserveIn + amountIn;  const newReserveOut = reserveOut - amountOut;  const executionPrice = (amountIn * 10n ** 18n) / amountOut;  const priceImpact =    Number(((executionPrice - spotPrice) * 10000n) / spotPrice) / 100;  return { amountOut, priceImpact };}// 鍩轰簬褰撳墠姹犲瓙鍌ㄥ锛屼及绠楀厬鎹㈣緭鍑恒€佺幇浠蜂笌鎵ц浠凤紙鍚墜缁垂锛?export async function getSwapQuote(ethAmount: bigint): Promise<{  fctOut: bigint;  priceImpact: number;  effectivePrice: bigint;  spotPrice: bigint;} | null> {  if (!isMainnet()) {    console.log("[INFO] 娴嬭瘯缃戜笉鍙敤鍏戞崲锛圫wapping not available on testnet锛?);    return null;  }  try {    // Get current reserves    const pairAddr = await resolveFacetPair();    const [reserve0, reserve1] = await facetClient.readContract({      address: pairAddr,      abi: UNISWAP_V2_PAIR_ABI,      functionName: "getReserves",    });    // Token0 is WETH, Token1 is FCT    const wethReserve = reserve0;    const fctReserve = reserve1;    // Calculate swap output and price impact    const { amountOut, priceImpact } = calculatePriceImpact(      ethAmount,      wethReserve,      fctReserve    );    // Calculate prices    const spotPrice = (wethReserve * 10n ** 18n) / fctReserve;    const effectivePrice = (ethAmount * 10n ** 18n) / amountOut;    return {      fctOut: amountOut,      priceImpact,      effectivePrice,      spotPrice,    };  } catch (error) {    console.error("[ERROR] 鑾峰彇鍏戞崲鎶ヤ环澶辫触锛團ailed to get swap quote锛?", error);    return null;  }}// --- New thin exports for arbiter ---export async function getSpotPx(): Promise<{ fctPerEth: bigint; ethUsd?: number }> {  // On testnet there is no trading pair; return neutral value.  if (!isMainnet()) return { fctPerEth: 0n };  // Use pair reserves for spot; optionally add ETH/USD  const pairAddr = await resolveFacetPair();  const [reserve0, reserve1] = await facetClient.readContract({    address: pairAddr,    abi: UNISWAP_V2_PAIR_ABI,    functionName: "getReserves",  });  const wethReserve = reserve0;  const fctReserve = reserve1;  if (wethReserve === 0n || fctReserve === 0n) return { fctPerEth: 0n };  const fctPerEth = (fctReserve * 10n ** 18n) / wethReserve;  // Optional: pull ETH/USD similar to miner, with fallback  let ethUsd: number | undefined = undefined;  try {    const resp = await fetch("https://eth-price.facet.org");    if (resp.ok) { const j = await resp.json(); const p = parseFloat(j.priceInUSD); if (isFinite(p)) ethUsd = p; }  } catch {}  return { fctPerEth, ethUsd };}export async function getV2Reserves(): Promise<{ RxFCT: bigint; RyETH: bigint; feeBps: number }> {  if (!isMainnet()) throw new Error("pair not available on testnet");  const pairAddr = await resolveFacetPair();  const [reserve0, reserve1] = await facetClient.readContract({    address: pairAddr,    abi: UNISWAP_V2_PAIR_ABI,    functionName: "getReserves",  });  // token0=WETH, token1=FCT  return { RxFCT: reserve1, RyETH: reserve0, feeBps: 30 };}export async function swapFCTForETH(amountIn: bigint, minOutBpsSafety: number, usePrivateRelay: boolean): Promise<string> {  // Compute minOut via router quote then apply safety bps  const path = [WRAPPED_FCT_ADDRESS, WETH_ADDRESS] as const;  try {\n  const amounts = await facetClient.readContract({\n    address: UNISWAP_V2_ROUTER,\n    abi: UNISWAP_V2_ROUTER_ABI,\n    functionName: 'getAmountsOut',\n    args: [amountIn, path],\n  }) as readonly bigint[];\n  outEst = (amounts as readonly bigint[])[(amounts as readonly bigint[]).length - 1] as bigint;\n} catch {\n  // Fallback: compute via reserves if router quote reverts\n  const pairAddr = await resolveFacetPair();\n  const [reserve0, reserve1] = await facetClient.readContract({ address: pairAddr, abi: UNISWAP_V2_PAIR_ABI, functionName: 'getReserves' });\n  const RxFCT = reserve1 as bigint; const RyETH = reserve0 as bigint;\n  const amountInWithFee = amountIn * 997n;\n  const numerator = amountInWithFee * RyETH;\n  const denominator = RxFCT * 1000n + amountInWithFee;\n  outEst = denominator > 0n ? numerator / denominator : 0n;\n}  let outEst = 0n;  const minOut = (outEst * BigInt(10_000 - Math.max(0, Math.min(10_000, Math.floor(minOutBpsSafety))))) / 10_000n;  const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);  // Ensure allowance  const ERC20_ABI = parseAbi([    "function allowance(address owner, address spender) view returns (uint256)",    "function approve(address spender, uint256 amount) returns (bool)",  ]);  const allowance = await facetClient.readContract({    address: WRAPPED_FCT_ADDRESS,    abi: ERC20_ABI,    functionName: "allowance",    args: [account.address, UNISWAP_V2_ROUTER],  });  if ((allowance as bigint) < amountIn) {    const approveTx = await (facetWalletClient as any).sendTransaction({      to: WRAPPED_FCT_ADDRESS,      data: `0x095ea7b3${UNISWAP_V2_ROUTER.slice(2).padStart(64, '0')}${amountIn.toString(16).padStart(64, '0')}`,      value: 0n,    } as any);    await facetClient.waitForTransactionReceipt({ hash: approveTx as `0x${string}` });  }  // Send swapExactTokensForETH  const swapData = encodeAbiParameters(    parseAbiParameters("uint256, uint256, address[], address, uint256"),    [amountIn, minOut, path as readonly Address[], account.address, deadline]  );  const selector = "0x18cbafe5"; // swapExactTokensForETH  const txHash = await (facetWalletClient as any).sendTransaction({    to: UNISWAP_V2_ROUTER,    value: 0n,    data: `${selector}${swapData.slice(2)}`,  } as any);  return txHash as `0x${string}`;}// 鑷姩鍒囩墖锛氭寜缁欏畾鏈€澶ф粦鐐癸紙bps锛夋媶鍒?WFCT 鍗栧嚭浠介// 杩戜技娉曪細鍗曠墖澶у皬 鈮?RxFCT * maxSlippageBps / 10000// 杩斿洖姣忕墖鐨?amountIn锛圵FCT锛寃ei锛?export function splitForSlippage(  totalWFCT: bigint,  RxFCT: bigint,  RyETH: bigint,  maxSlippageBps: number = 80): bigint[] {  if (totalWFCT <= 0n) return [];  if (RxFCT <= 0n || RyETH <= 0n) return [totalWFCT];  const bps = Math.max(1, Math.min(10_000, Math.floor(maxSlippageBps)));  let approxSlice = (RxFCT * BigInt(bps)) / 10_000n; // 鈮?鍗曠墖涓婇檺  if (approxSlice <= 0n) approxSlice = 1n;  // 鐗囨暟 = ceil(total / approxSlice)锛岄檺鍒跺埌鍚堢悊涓婇檺閬垮厤杩囧浜ゆ槗  let num = Number((totalWFCT + approxSlice - 1n) / approxSlice);  const MAX_SLICES = 50; // 淇濇姢锛氭渶澶?50 绗?  if (num > MAX_SLICES) num = MAX_SLICES;  if (num < 1) num = 1;  const base = totalWFCT / BigInt(num);  let rem = totalWFCT % BigInt(num);  const slices: bigint[] = [];  for (let i = 0; i < num; i++) {    const extra = rem > 0n ? 1n : 0n;    if (rem > 0n) rem -= 1n;    slices.push(base + extra);  }  return slices.filter((x) => x > 0n);}// 灏?WFCT 鎸夋渶澶ф粦鐐归槇鍊煎垏鐗囷紝閫愮瑪鍗栧嚭涓?WETH锛堥『搴忔墽琛岋紝杩戜技 TWAP锛?// - maxSlippageBps: 鍗曠墖鏈€澶у厑璁告粦鐐癸紙榛樿 80 = 0.8%锛?// - minOutSafetyBps: 瀵?Router 鎶ヤ环搴旂敤鐨勬渶灏忔敹鍏ュ畨鍏ㄨ竟闄咃紙榛樿 50bp锛?export async function sellWFCTforWETH_TWAP(  totalWFCT: bigint,  maxSlippageBps: number = 80,  minOutSafetyBps: number = 50): Promise<string[]> {  if (!isMainnet() || !networkConfig.fctWethPair) {    throw new Error("Swapping not available on testnet");  }  if (totalWFCT <= 0n) return [];  const { RxFCT, RyETH } = await getV2Reserves();  const slices = splitForSlippage(totalWFCT, RxFCT, RyETH, maxSlippageBps);  console.log("\n=== Sell WFCT -> WETH (TWAP) ===");  console.log("Total WFCT:", formatEther(totalWFCT));  console.log("Max per-slice slippage:", (Math.max(1, Math.min(10_000, maxSlippageBps)) / 100).toFixed(2), "%");  console.log("MinOut safety:", Math.max(0, Math.min(5_000, minOutSafetyBps)), "bps");  console.log("Slices:", slices.length);  const txHashes: string[] = [];  for (let i = 0; i < slices.length; i++) {    const amt = slices[i];    console.log(`\n[${i + 1}/${slices.length}] Selling WFCT:`, formatEther(amt));    const tx = await swapFCTForETH(amt, minOutSafetyBps, false);    console.log("  sent:", tx);    const r = await facetClient.waitForTransactionReceipt({ hash: tx as `0x${string}` });    console.log("  confirmed in block:", r.blockNumber);    txHashes.push(tx);  }  return txHashes;}// 鎵ц鍏戞崲锛氳缃渶灏忓彲鎺ユ敹鏁伴噺锛堟寜婊戠偣璁＄畻锛夛紝璋冪敤 Router 杩涜 swapexport async function executeSwap(  ethAmount: bigint,  minFctOut: bigint,  slippageBps: number = 50 // 0.5% 榛樿婊戠偣): Promise<string | null> {  try {    console.log("\n=== Facet 涓婃墽琛屽厬鎹?| Executing Swap on Facet ===");    console.log("鍏戞崲鏁伴噺 Swapping:", formatEther(ethAmount), "ETH");    console.log("鏈€灏戝緱鍒?Min FCT out:", formatEther(minFctOut), "FCT");    console.log("婊戠偣 Slippage:", slippageBps / 100, "%");    // Calculate minimum output with slippage    const minOutWithSlippage =      (minFctOut * BigInt(10000 - slippageBps)) / 10000n;    // Set deadline to 20 minutes from now    const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);    // Path: WETH -> Wrapped FCT    const path = [WETH_ADDRESS, WRAPPED_FCT_ADDRESS];    // Encode the swap call    const swapData = encodeAbiParameters(      parseAbiParameters("uint256, address[], address, uint256"),      [        minOutWithSlippage,        path as readonly Address[],        account.address,        deadline,      ]    );    console.log("\n鍙戦€佸厬鎹氦鏄撯€?| Sending swap transaction鈥?);    // Send the swap transaction    const txHash = await (facetWalletClient as any).sendTransaction({      to: UNISWAP_V2_ROUTER,      value: ethAmount,      data: `0x7ff36ab5${swapData.slice(2)}`, // swapExactETHForTokens selector    } as any);    console.log("Transaction sent:", txHash);    console.log("Waiting for confirmation...");    // Wait for confirmation    const receipt = await facetClient.waitForTransactionReceipt({      hash: txHash,      timeout: 30_000,    });    console.log("鉁?Swap confirmed in block:", receipt.blockNumber);    return txHash;  } catch (error) {    console.error("Swap failed:", error);    return null;  }}// Compare mining vs swapping// 鈥滄寲鐭?vs 鍏戞崲鈥濆姣旓細鍦ㄧ浉鍚?ETH 鏀嚭涓嬫瘮杈?FCT 鏁伴噺涓庡崟浠?export async function compareMiningVsSwapping(  ethToSpend: bigint,  miningFctAmount: bigint,  miningCostPerFct: bigint): Promise<void> {  const swapQuote = await getSwapQuote(ethToSpend);  if (!swapQuote) {    console.log("Could not get swap quote for comparison");    return;  }  console.log("\n=== Mining vs Swapping Comparison ===");  // Mining option  console.log("\n馃摝 MINING:");  console.log("  FCT received:", formatEther(miningFctAmount), "FCT");  console.log("  Cost per FCT:", formatEther(miningCostPerFct), "ETH");  // Swapping option  console.log("\n馃挶 SWAPPING:");  console.log("  FCT received:", formatEther(swapQuote.fctOut), "FCT");  console.log("  Cost per FCT:", formatEther(swapQuote.effectivePrice), "ETH");  console.log("  Price impact:", swapQuote.priceImpact.toFixed(2), "%");  // Comparison  const swapIsBetter = swapQuote.fctOut > miningFctAmount;  const percentDiff =    ((Number(swapQuote.fctOut) - Number(miningFctAmount)) /      Number(miningFctAmount)) *    100;  console.log("\n馃搳 RECOMMENDATION:");  if (swapIsBetter) {    console.log(      `  鉁?SWAP is better: Get ${Math.abs(percentDiff).toFixed(1)}% more FCT`    );    if (swapQuote.priceImpact > 1) {      console.log(        `  鈿狅笍  Warning: High price impact (${swapQuote.priceImpact.toFixed(          2        )}%)`      );    }  } else {    console.log(      `  鉀忥笍  MINING is better: Get ${Math.abs(percentDiff).toFixed(        1      )}% more FCT`    );  }  // Show arbitrage opportunity if significant  if (Math.abs(percentDiff) > 5) {    console.log("\n馃挵 ARBITRAGE OPPORTUNITY:");    if (swapIsBetter) {      console.log(        "  Buy from pool, wait for mint rate adjustment, then mine and sell"      );    } else {      console.log("  Mine FCT and sell to pool for profit");    }  }}// Main function for standalone usage// 鍛戒护琛屽叆鍙ｏ細quote <eth> 鑾峰彇鎶ヤ环锛泂wap <eth> [slippage_bps] 鎵ц鍏戞崲async function main() {  const args = process.argv.slice(2);  if (args.length === 0) {    console.log("Usage:");    console.log("  bun facet-swapper.ts quote <eth_amount>   - Get swap quote");    console.log(      "  bun facet-swapper.ts swap <eth_amount> [slippage_bps] - Execute swap"    );    console.log(      "  bun facet-swapper.ts sell-wfct <wfct_amount> [max_slip_bps] [minout_safety_bps] - Sell WFCT->WETH in slices"    );    console.log("Example:");    console.log("  bun facet-swapper.ts quote 0.01");    console.log("  bun facet-swapper.ts swap 0.01 100  # 1% slippage");    console.log("  bun facet-swapper.ts sell-wfct 123.45 80 50  # per-slice <=0.8% slip, 50bp safety");    process.exit(1);  }  const command = args[0];  const ethAmount = parseEther(args[1] || "0");  if (command === "quote") {    const quote = await getSwapQuote(ethAmount);    if (quote) {      console.log("\n=== Swap Quote ===");      console.log("Input:", formatEther(ethAmount), "ETH");      console.log("Output:", formatEther(quote.fctOut), "FCT");      console.log("Spot price:", formatEther(quote.spotPrice), "ETH per FCT");      console.log(        "Effective price:",        formatEther(quote.effectivePrice),        "ETH per FCT"      );      console.log("Price impact:", quote.priceImpact.toFixed(2), "%");    }  } else if (command === "swap") {    const slippage = args[2] ? parseInt(args[2]) : 50; // Default 0.5%    const quote = await getSwapQuote(ethAmount);    if (quote) {      console.log("\n=== Swap Preview ===");      console.log("Expected FCT:", formatEther(quote.fctOut), "FCT");      console.log("Price impact:", quote.priceImpact.toFixed(2), "%");      if (quote.priceImpact > 5) {        console.log(          "\n鈿狅笍  WARNING: High price impact! Consider smaller swap or mining instead."        );      }      // Non-interactive execution: proceed directly      await executeSwap(ethAmount, quote.fctOut, slippage);    }  } else if (command === "sell-wfct") {    // Sell WFCT for WETH with automatic slicing by max slippage per slice (default 80 bps)    const wfctAmount = parseEther(args[1] || "0");    const maxSlipBps = args[2] ? Math.max(1, Math.min(10_000, parseInt(args[2]))) : 80;    const safetyBps = args[3] ? Math.max(0, Math.min(5_000, parseInt(args[3]))) : 50; // default 50 bps    const txs = await sellWFCTforWETH_TWAP(wfctAmount, maxSlipBps, safetyBps);    console.log("\nSell complete. Tx hashes:");    for (const h of txs) console.log("  ", h);  }}// Functions are already exported inline// Run if called directly// Run if called directly (CommonJS-friendly)// eslint-disable-next-line @typescript-eslint/no-explicit-anydeclare const require: any | undefined;declare const module: any | undefined;if (typeof require !== 'undefined' && typeof module !== 'undefined' && require.main === module) {  main().catch(console.error);}